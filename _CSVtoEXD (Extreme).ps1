$host.UI.RawUI.WindowTitle = "CSV -> EXD (Extreme)"

# Function's source: https://www.sans.org/blog/powershell-byte-array-and-hex-functions/
function Convert-ByteArrayToHexString
{
################################################################
#.Synopsis
# Returns a hex representation of a System.Byte[] array as
# one or more strings. Hex format can be changed.
#.Parameter ByteArray
# System.Byte[] array of bytes to put into the file. If you
# pipe this array in, you must pipe the [Ref] to the array.
# Also accepts a single Byte object instead of Byte[].
#.Parameter Width
# Number of hex characters per line of output.
#.Parameter Delimiter
# How each pair of hex characters (each byte of input) will be
# delimited from the next pair in the output. The default
# looks like "0x41,0xFF,0xB9" but you could specify "\x" if
# you want the output like "\x41\xFF\xB9" instead. You do
# not have to worry about an extra comma, semicolon, colon
# or tab appearing before each line of output. The default
# value is ",0x".
#.Parameter Prepend
# An optional string you can prepend to each line of hex
# output, perhaps like '$x += ' to paste into another
# script, hence the single quotes.
#.Parameter AddQuotes
# A switch which will enclose each line in double-quotes.
#.Example
# [Byte[]] $x = 0x41,0x42,0x43,0x44
# Convert-ByteArrayToHexString $x
#
# 0x41,0x42,0x43,0x44
#.Example
# [Byte[]] $x = 0x41,0x42,0x43,0x44
# Convert-ByteArrayToHexString $x -width 2 -delimiter "\x" -addquotes
#
# "\x41\x42"
# "\x43\x44"
################################################################
[CmdletBinding()] Param (
[Parameter(Mandatory = $True, ValueFromPipeline = $True)] [System.Byte[]] $ByteArray,
[Parameter()] [Int] $Width = 10,
[Parameter()] [String] $Delimiter = ",0x",
[Parameter()] [String] $Prepend = "",
[Parameter()] [Switch] $AddQuotes )
 
if ($Width -lt 1) { $Width = 1 }
if ($ByteArray.Length -eq 0) { Return }
$FirstDelimiter = $Delimiter -Replace "^[\,\:\t]",""
$From = 0
$To = $Width - 1
Do
{
$String = [System.BitConverter]::ToString($ByteArray[$From..$To])
$String = $FirstDelimiter + ($String -replace "\-",$Delimiter)
if ($AddQuotes) { $String = '"' + $String + '"' }
if ($Prepend -ne "") { $String = $Prepend + $String }
$String
$From += $Width
$To += $Width
} While ($From -lt $ByteArray.Length)
}

# Function's source: https://www.sans.org/blog/powershell-byte-array-and-hex-functions/
function Convert-HexStringToByteArray
{
################################################################
#.Synopsis
# Convert a string of hex data into a System.Byte[] array. An
# array is always returned, even if it contains only one byte.
#.Parameter String
# A string containing hex data in any of a variety of formats,
# including strings like the following, with or without extra
# tabs, spaces, quotes or other non-hex characters:
# 0x41,0x42,0x43,0x44
# \x41\x42\x43\x44
# 41-42-43-44
# 41424344
# The string can be piped into the function too.
################################################################
[CmdletBinding()]
Param ( [Parameter(Mandatory = $True, ValueFromPipeline = $True)] [String] $String )
 
#Clean out whitespaces and any other non-hex crud.
$String = $String.ToLower() -replace '[^a-f0-9\\,x\-\:]',"
 
#Try to put into canonical colon-delimited format.
$String = $String -replace '0x|\x|\-|,',':'
 
#Remove beginning and ending colons, and other detritus.
$String = $String -replace '^:+|:+$|x|\',"
 
#Maybe there's nothing left over to convert...
if ($String.Length -eq 0) { ,@() ; return }
 
#Split string with or without colon delimiters.
if ($String.Length -eq 1)
{ ,@([System.Convert]::ToByte($String,16)) }
elseif (($String.Length % 2 -eq 0) -and ($String.IndexOf(":") -eq -1))
{ ,@($String -split '([a-f0-9]{2})' | foreach-object { if ($_) {[System.Convert]::ToByte($_,16)}}) }
elseif ($String.IndexOf(":") -ne -1)
{ ,@($String -split ':+' | foreach-object {[System.Convert]::ToByte($_,16)}) }
else
{ ,@() }
#The strange ",@(...)" syntax is needed to force the output into an
#array even if there is only one element in the output (or none).
}

# Following function was written by me
function Convert-TagsToVariables
{
################################################################
#.Synopsis
# Convert variable tags that were generated by "_EXDtoCSV (Extreme).ps1"
# into 0x02..0x03 variables. Output is ByteArray.
#.Parameter ByteArray
# System.Byte[] array of bytes of the target string.
#.Example
# [Byte[]] $x = @( [bytes that result in string "<var 08 E905 ((а)) (()) /var>"] )
# Convert-TagsToVariables $x
#
# @(0x02,0x08,0x09,0xE9,0x05,0xFF,0x03,0xD0,0xB0,0xFF,0x01,0x03)
################################################################
[CmdletBinding()] Param (
[Parameter(Mandatory = $True, ValueFromPipeline = $True)] [System.Byte[]] $ByteArray
)
# It's much easier to operate with the string as an actual string so we're gonna convert it.
$input_string = Convert-ByteArrayToHexString $ByteArray -Delimiter '' -Width $ByteArray.Count

# We'll start with <br>, column separator, and <nl> real quick since they're the easiest and safest to clear
$memory = $(Select-String -InputObject $input_string -Pattern "3C62723E" -AllMatches).Matches # "<br>"
foreach ($match in $memory) {
    $input_string = $input_string.Remove($match.Index, 8).Insert($match.Index, "02100103")
}
$column_separator_hex = Convert-ByteArrayToHexString $COLUMN_SEPARATOR_BYTE -Delimiter ''
$memory = $(Select-String -InputObject $input_string -Pattern $column_separator_hex -AllMatches).Matches
if ($memory) { [array]::Reverse($memory) }
# String size will change so indexes will not match anymore.
# Working on the string from the end to the start mitigates this issue.
foreach ($match in $memory) {
    $input_string = $input_string.Remove($match.Index, $column_separator_hex.Length).Insert($match.Index, "00")
}
$memory = $(Select-String -InputObject $input_string -Pattern "3C6E6C3E" -AllMatches).Matches # "<nl>"
if ($memory) { [array]::Reverse($memory) } # See explanation above
foreach ($match in $memory) {
    $input_string = $input_string.Remove($match.Index, 8).Insert($match.Index, "0A")
}

$start_memory = [System.Collections.ArrayList]@()
$looking_for_var = $true

for ($i = 0; $i -lt $input_string.Length-8; $i += 2) {
    if ( $looking_for_var -and ($input_string.Substring($i, 10) -eq '3C76617220') ) { # '<var '
        $looking_for_var = $false
        $null = $start_memory.Add($i) # Remember position for later. String manipulation will happen at the ends of vars and options
        $i += 14 # Skipping over the type too
    }
    if ($input_string.Substring($i, 4) -eq '2828') { # "(("
        $looking_for_var = $true
        $null = $start_memory.Add($i) # Same as above
        $i += 2
        continue
    }
    if ($input_string.Substring($i, 4) -eq '2929') { # "))"
        if ($input_string.Substring($i, 6) -eq '292929') { continue } # ")))"
        $looking_for_var = $false
        $input_string = $input_string.Remove($i, 4)
        $size = ($i - $start_memory[-1] - 4) / 2   # 4 is length of "(("
        if (($size -gt 0) -and ($size % 0x100 -eq 0)) {
            $input_string = $input_string.Remove($start_memory[-1], 4).Insert($start_memory[-1], "FFF1{0:X2}" -f ($size / 0x100))
            $i += 2
        } elseif ($size -gt 256) {
            $input_string = $input_string.Remove($start_memory[-1], 4).Insert($start_memory[-1], "FFF2{0:X4}" -f $size)
            $i += 4
        } elseif ($size -gt 214) {
            $input_string = $input_string.Remove($start_memory[-1], 4).Insert($start_memory[-1], "FFF0{0:X2}" -f $size)
            $i += 2
        } else {
            $input_string = $input_string.Remove($start_memory[-1], 4).Insert($start_memory[-1], "FF{0:X2}" -f ($size+1))
        }
        $start_memory.RemoveAt($start_memory.Count-1)
    }
    if ($input_string.Substring($i, 10) -eq '2F7661723E') { # "/var>"
        $looking_for_var = $true
        $type_hex = $input_string.Substring($start_memory[-1]+10, 4)
        $type = "{0}{1}" -f [char][uint32]$('0x' + $type_hex.Substring(0, 2)), [char][uint32]$('0x' + $type_hex.Substring(2, 2))
        $size = ($i - $start_memory[-1] - 14) / 2 + 1   # 14 is length of "<var XX"; +1 is 03 in the end
        $input_string = $input_string.Remove($i, 10).Insert($i, "03")
        if (($size-1 -gt 0) -and (($size - 1) % 0x100 -eq 0)) {
            $input_string = $input_string.Remove($start_memory[-1], 14).Insert($start_memory[-1], $("02{0}F1{1:X2}" -f $type, (($size-1) / 0x100) ))
            $i -= 6 
        } elseif ($size -gt 257) {
            $input_string = $input_string.Remove($start_memory[-1], 14).Insert($start_memory[-1], $("02{0}F2{1:X4}" -f $type, ($size-1) ))
            $i -= 4
        } elseif ($size -gt 215) {
            $input_string = $input_string.Remove($start_memory[-1], 14).Insert($start_memory[-1], $("02{0}F0{1:X2}" -f $type, ($size-1) ))
            $i -= 6
        } else {
            $input_string = $input_string.Remove($start_memory[-1], 14).Insert($start_memory[-1], $("02{0}{1:X2}" -f $type, $size) )
            $i -= 8
        }
        $start_memory.RemoveAt($start_memory.Count-1)
    }
    if (-not $looking_for_var) { # " "
        if ($input_string.Substring($i, 2) -eq "20") {
            $input_string = $input_string.Remove($i, 2)
            $i -= 2
        } else {
            $byte_hex = $input_string.Substring($i, 4)
            $byte = "{0}{1}" -f [char][uint32]$('0x' + $byte_hex.Substring(0, 2)), [char][uint32]$('0x' + $byte_hex.Substring(2, 2))
            $input_string = $input_string.Remove($i, 4).Insert($i, $byte)
        }
    }
}

$ByteArray = Convert-HexStringToByteArray $input_string
return $ByteArray
}

while ($true) {

"Drag and drop EXH file and press Enter."
$exh_path = Read-Host ' '
if ( $exh_path.StartsWith('"') -and $exh_path.EndsWith('"')) {
    $exh_path = $exh_path.Substring(1, $exh_path.Length-2)
}
if (!$(Test-Path $exh_path)) {
    "EXH file wasn't found at $exh_path.`n"
    continue
}
$exh_file_name = $(Split-Path $exh_path -Leaf) -replace ".{4}$"
$current_dir = $(Split-Path $exh_path -Parent)
$EXD_DIR          = "$current_dir"
$BIN_DIR          = "$current_dir\bin"
$CSV_DIR          = "$current_dir\csv"

$csv_files = Get-ChildItem -Path "$CSV_DIR\$($exh_file_name)_*_*.csv" -Name
$csv_path = "$CSV_DIR\"
if ($csv_files.Count -gt 1) {
    "Several CSV files were found:"
    for ($_i = 0; $_i -lt $csv_files.Count; $_i++) {
        "  $($_i+1). $($csv_files[$_i])"
    }
    while ($true) {
        $_choice = [int]$(Read-Host "Choose one")
        $_choice--
        if ( ($_choice -gt -1) -and ($_choice -lt $csv_files.Count) ) {
            "$($csv_files[$_choice]) was chosen."
            $csv_path += $csv_files[$_choice]
            break
        }
        "Try again."
    }
} else {
    "$csv_files was found."
    $csv_path += $csv_files
}
$exd_file_name = $(Split-Path $csv_path -Leaf).TrimEnd(".csv")

$bin_path = "$BIN_DIR\$exd_file_name.bin"
if (!$(Test-Path $bin_path)) {
    "BIN file wasn't found at $bin_path.`n"
    continue
}
$exd_path = "$EXD_DIR\$exd_file_name.exd"
if (Test-Path $exd_path) {
    $_answer = $(Read-Host "$exd_path already exists. Overwrite? (Y/n)").ToLower()
    switch ($_answer) {
        "n" { continue }
        default {}
    }
}
"Choose what to do with '<index>_' at the start of translation fields:"
$_answer = $(Read-Host "Add if doesn't exist / Remove if exists / do Nothing (a/r/N)").ToLower()
switch ($_answer) {
    "a" { $INDEXES_CHOICE = 1; break }
    "r" { $INDEXES_CHOICE = 2; break }
    default { $INDEXES_CHOICE = 0; break }
}

$exh = $null
$bin = $null
$csv = $null
while ($true) {
    $exh = [System.IO.File]::ReadAllBytes($exh_path)
    $bin = [System.IO.File]::ReadAllBytes($bin_path)
    $csv = [System.IO.File]::ReadAllBytes($csv_path)  # For taking strings as byte arrays
    if ($exh -and $bin -and $csv) { break }
    "Error while trying to read following file(s):"
    if (!$exh) { "$exh_path" }
    if (!$bin) { "$bin_path" }
    if (!$csv) { "$csv_path" }
    "If they exist they could be locked by some program."
    $null = Read-Host "Press Enter when you're ready to try again."
}
# For easier parsing we'll make a single string out f CSV. I'm going to use CP1251
# here so that every byte would have a representation. Any single-byte codepage
# would suffice to be honest. The point is to have $csv_string's indexes correspond
# to indexes of $csv[].
$csv_string = [System.Text.Encoding]::GetEncoding(1252).GetString($csv)

# Step 0. Collect data from EXH file
$data_chunk_size = [uint32](Convert-ByteArrayToHexString $exh[0x6..0x7] -Delimiter '' -Prepend '0x')
$number_of_datasets = [uint32](Convert-ByteArrayToHexString $exh[0x8..0x9] -Delimiter '' -Prepend '0x')
$string_offsets_in_datachunks = New-Object System.Collections.ArrayList
for ($_i = 0; $_i -lt $number_of_datasets; $_i++) {
    $_offset = 0x20 + $_i*4
    if ( @(Compare-Object $exh[$_offset..($_offset+1)] @( 0x00, 0x00 ) ).Length -eq 0 ) {
        $_string_offset = [uint32](Convert-ByteArrayToHexString $exh[($_offset+2)..($_offset+3)] -Delimiter '' -Prepend '0x')
        $null = $string_offsets_in_datachunks.Add($_string_offset)
    }
}

$UNIX_NEW_LINE = [byte]0x0A
$MAC_NEW_LINE = [byte]0x0D
# Adjust according to what's set in _EXDtoCSV (Extreme).ps1
$NEW_LINE = @( $MAC_NEW_LINE, $UNIX_NEW_LINE)
$NEW_LINE_STRING = [System.Text.Encoding]::ASCII.GetString($NEW_LINE)

# Step 1. Collect raw indexes, strings, and their offsets into the $row_data table
#  Expected format of the rows:
#    0xXXXXXXXX┃<translation>┃<source><new_line>0xYYY...
#        1         2         3         4         5
#    678901234567890123456789012345678901234567890123456
#  <Source> field is ignored here.
#  If there are several strings per row, there are separated by 0x00 byte in
#  source string. We'll be looking for this byte here to separate the strings
#  in a row and get their new offsets for an according row chunk.
$row_start_index = 0
$row_end_index = 0
$row_data = New-Object System.Collections.ArrayList
$SEARCH_STRING = "$($NEW_LINE_STRING)0x"
# If you're going to change the separator, make sure the script file is in UTF-8 BOM
$CSV_SEPARATOR = '┃'
$CSV_SEPARATOR_BYTE = [System.Text.Encoding]::UTF8.GetBytes($CSV_SEPARATOR)
$CSV_SEPARATOR_SINGLE_BYTES = [System.Text.Encoding]::GetEncoding(1252).GetString($CSV_SEPARATOR_BYTE)
$COLUMN_SEPARATOR = '<tab>' # Tab
$COLUMN_SEPARATOR_BYTE = [System.Text.Encoding]::UTF8.GetBytes($COLUMN_SEPARATOR)
$EXD_INDEX_LENGTH = "0x00000000".Length
$NEW_LINE_LENGTH = $NEW_LINE.Count

$current_progress = 0
$1_percent = $csv_string.Length / 100
do {
    if ( $row_start_index -gt ($1_percent * $current_progress) ) {
        Write-Progress -Activity "Converting CSV to EXD" -CurrentOperation "Step 1. Collecting indexes, strings, and their offsets" -Status "$current_progress% Complete:" -PercentComplete $current_progress
        $current_progress += 1
    }

    $row_start_index = $csv_string.IndexOf($SEARCH_STRING, $row_end_index) + $NEW_LINE_LENGTH
    $row_end_index = $csv_string.IndexOf($SEARCH_STRING, $row_start_index) - 1
    if ($row_end_index -eq (-1 - $NEW_LINE_LENGTH)) {
        $row_end_index = $csv_string.Length - $NEW_LINE_LENGTH
    }

    $exd_index = [uint32]($csv_string.Substring($row_start_index, $EXD_INDEX_LENGTH))
    $exd_index_hex = "{0:X}_" -f $exd_index
    # "$exd_index_hex"
    $exd_index_byte = [System.Text.Encoding]::ASCII.GetBytes($exd_index_hex)

    $row_translation_start_index = $csv_string.IndexOf($CSV_SEPARATOR_SINGLE_BYTES, $row_start_index) + $CSV_SEPARATOR_BYTE.Count
    $row_translation_end_index = $csv_string.IndexOf($CSV_SEPARATOR_SINGLE_BYTES, $row_translation_start_index) - 1
    $row_translation_length = $row_translation_end_index - $row_translation_start_index + 1

    if (($INDEXES_CHOICE -eq 1) -and ($csv_string.Substring($row_translation_start_index, $exd_index_hex.Length) -ne $exd_index_hex)) {
        $_add_index_bytes = $true
    } elseif (($INDEXES_CHOICE -eq 2) -and $csv_string.Substring($row_translation_start_index, $row_translation_length).StartsWith($exd_index_hex) ) {
        $row_translation_start_index += $exd_index_hex.Length
        $row_translation_length = $row_translation_end_index - $row_translation_start_index + 1
    }
    # Even though in theory we could avoid using byte arrays and pass a string instead,
    # we're still going to get byte array to be safe of PowerShell conversions.
    if ($row_translation_length -gt 0) {
        if ( ($INDEXES_CHOICE -eq 1) -and $_add_index_bytes) {
            $translation_bytes = $exd_index_byte + $csv[$row_translation_start_index..$row_translation_end_index]
            $_add_index_bytes = $false   # Reset variable
        } else {
            $translation_bytes = $csv[$row_translation_start_index..$row_translation_end_index]
        }
        $translation_bytes = Convert-TagsToVariables $translation_bytes
    } else { $translation_bytes = @() }
    
    # Determining offsets to columns
    $strings_offsets = New-Object System.Collections.ArrayList
    $null = $strings_offsets.Add( 0 )    # First string always starts at offset 0
    for ($_index = 0; $_index -lt $translation_bytes.Count; $_index++) {
        if ($translation_bytes[$_index] -eq [byte]0x00) {
            $null = $strings_offsets.Add($_index + 1)
        }
    }

    $null = $row_data.Add(@($exd_index, $translation_bytes, $strings_offsets) )
} while ($csv_string.IndexOf($SEARCH_STRING, $row_end_index) -ne -1)
"Don't mind the IndexOf error, it's fine."
Write-Progress -Activity "Converting CSV to EXD" -CurrentOperation "Step 1. Collecting indexes, strings, and their offsets" -Status "Completed" -Completed

# Step 2. Edit BIN data
$current_progress = 0
$1_percent = $row_data.Count / 100
for ($_i = 0; $_i -lt $row_data.Count; $_i++) {
    if ( $i -gt ($1_percent * $current_progress) ) {
        Write-Progress -Activity "Converting CSV to EXD" -CurrentOperation "Step 2. Editing BIN data" -Status "$current_progress% Complete:" -PercentComplete $current_progress
        $current_progress += 1
    }
    $_offset = $_i * $data_chunk_size
    $_string_offsets_bytes = New-Object System.Collections.ArrayList
    foreach ($_raw_data_piece in $row_data[$_i][2]) {
        $_string_offset_array = New-Object System.Collections.ArrayList
        foreach ($_byte in $(Convert-HexStringToByteArray ("{0:X8}" -f $_raw_data_piece )) ) {
            $null = $_string_offset_array.Add( $_byte )
        }
        $null = $_string_offsets_bytes.Add($_string_offset_array)
    }
    $_count = 0
    for ($_j = 0; $_j -lt $data_chunk_size; $_j++) {
        if ($string_offsets_in_datachunks -contains $_j) {
            for ($_k = 0; $_k -lt 4; $_k++) {
                if ($null -eq $_string_offsets_bytes[$_count]) {
                    $bin[($_offset+$_j+$_k)] = [byte]0x00
                } else {
                    $bin[($_offset+$_j+$_k)] = $_string_offsets_bytes[$_count][$_k]
                }
            }
            $_count++
        }
    }
}
Write-Progress -Activity "Converting CSV to EXD" -CurrentOperation "Step 2. Editing BIN data" -Status "Completed" -Completed

# Step 3. Setting up actual data table that's going to go in file
#         + Remembering offsets for the offset table
$offset_table_size = $row_data.Count * 8
$data_table_offset = $offset_table_size + 0x20

$index_offset_table = New-Object System.Collections.ArrayList
$data_table = New-Object System.Collections.ArrayList
$_current_offset = $data_table_offset
$current_progress = 0
$1_percent = $row_data.Count / 100
# $_i = 1 # For debug to jump to specified string in CSV
for ($_i = 0; $_i -lt $row_data.Count; $_i++)
{
    if ( $i -gt ($1_percent * $current_progress) ) {
        Write-Progress -Activity "Converting CSV to EXD" -CurrentOperation "Step 3. Preparing data table" -Status "$current_progress% Complete:" -PercentComplete $current_progress
        $current_progress += 1
    }
    $null = $index_offset_table.Add(@($row_data[$_i][0],$_current_offset) )
    $_size = $data_chunk_size + $row_data[$_i][1].Length
    $_zeros = 4 - (2 + $_size) % 4     # Seems like padding is always aligned to 4
    foreach ($_byte in $(Convert-HexStringToByteArray ("{0:X8}" -f ($_size + $_zeros)) ) )
    {
        $null = $data_table.Add( $_byte )
    }
    $null = $data_table.Add( [byte]0x00 )
    $null = $data_table.Add( [byte]0x01 )
    for ($_j = 0; $_j -lt $data_chunk_size; $_j++)
    {
        $null = $data_table.Add( $bin[($_i*$data_chunk_size + $_j)] )
    }
    if ($row_data[$_i][1].Count -gt 0)
    {
        foreach ($_byte in $row_data[$_i][1] )
        {
            $null = $data_table.Add( $_byte )
        }
    }
    for ($_j = 0; $_j -lt $_zeros; $_j++)
    {
        $null = $data_table.Add( [byte]0x00 )
    }
    $_current_offset += 6 + $_size + $_zeros
}
[byte[]]$data_table = $data_table.ToArray() # Checking that we've got only bytes
Write-Progress -Activity "Converting CSV to EXD" -CurrentOperation "Step 3. Preparing data table" -Status "Completed" -Completed

# Step 4. Create offset table
$offset_table = [System.Collections.ArrayList]@()
foreach ($_index_offset_piece in $index_offset_table)
{
    foreach ($_byte in $(Convert-HexStringToByteArray ("{0:X8}" -f $_index_offset_piece[0]) ) )
    {
        $null = $offset_table.Add( $_byte )
    }
    foreach ($_byte in $(Convert-HexStringToByteArray ("{0:X8}" -f $_index_offset_piece[1]) ) )
    {
        $null = $offset_table.Add( $_byte )
    }
}

# Step 5. Header
$exd_header = [Byte[]]@(0x45,0x58,0x44,0x46,0x00,0x02,0x00,0x00) + 
    $(Convert-HexStringToByteArray ("{0:X8}" -f $offset_table.Count) ) +
    $(Convert-HexStringToByteArray ("{0:X8}" -f $data_table.Count) ) +
    @([byte]0x00) * 16

# Step 6. Check everything and put everything in a new file
if ($null -eq $exd_header) {
    "Something went wrong. EXD header turned out empty.`n"
    Remove-Variable data_table
    continue
}
if ($null -eq $offset_table) {
    "Something went wrong. Offset table turned out empty.`n"
    Remove-Variable data_table
    continue
}
if ($null -eq $data_table) {
    "Something went wrong. Data table turned out empty.`n"
    Remove-Variable data_table
    continue
}
Set-Content -Value ($exd_header + $offset_table + $data_table) -Encoding Byte -Path $exd_path
"$exd_path exported.`n"
Remove-Variable data_table
}